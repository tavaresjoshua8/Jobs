package com.gamingmesh.jobs.config;

import java.util.HashMap;
import java.util.Set;

import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.NamespacedKey;
import org.bukkit.block.Block;
import org.bukkit.util.Vector;

import com.gamingmesh.jobs.Jobs;
import com.gamingmesh.jobs.container.ActionInfo;
import com.gamingmesh.jobs.container.ActionType;
import com.gamingmesh.jobs.container.BlockProtection;
import com.gamingmesh.jobs.container.ExploitProtection;
import com.gamingmesh.jobs.container.JobsPlayer;

import net.Zrips.CMILib.ActionBar.CMIActionBar;
import net.Zrips.CMILib.Container.CMIBlock;
import net.Zrips.CMILib.Container.CMIBlock.Bisect;
import net.Zrips.CMILib.Items.CMIMaterial;
import net.Zrips.CMILib.PersistentData.CMIChunkPersistentDataContainer;

public class ExploitProtectionManager {

    private static final String NAMEGENERAL = "JobsExploitProtection";
    private static final String NAMETIME = "Time";
    private static final String NAMEPAID = "Paid";

    private HashMap<String, HashMap<String, chunkData>> map = new HashMap<>();

    class chunkData {
        private CMIChunkPersistentDataContainer container;
        private long lastClean = 0;

        chunkData(CMIChunkPersistentDataContainer container) {
            this.container = container;
            lastClean = System.currentTimeMillis();
        }

        public long getLastClean() {
            return lastClean;
        }

        public void setLastClean(long lastClean) {
            this.lastClean = lastClean;
        }

        public CMIChunkPersistentDataContainer getContainer() {
            return container;
        }
    }

    private CMIChunkPersistentDataContainer getPDC(Block block) {
        if (block == null)
            return null;
        return getPDC(block.getChunk());
    }

    private CMIChunkPersistentDataContainer getPDC(Chunk chunk) {
        if (chunk == null)
            return null;
        chunkData data = getChunkData(chunk);
        return data == null ? null : data.getContainer();
    }

    private chunkData getChunkData(Chunk chunk) {
        if (chunk == null)
            return null;
        HashMap<String, chunkData> world = map.computeIfAbsent(chunk.getWorld().getName(), x -> new HashMap<>());
        return world.computeIfAbsent(chunk.getX() + ":" + chunk.getZ(), x -> new chunkData(new CMIChunkPersistentDataContainer(NAMEGENERAL, chunk)));
    }

    public void removePDC(Chunk chunk) {
        if (!Jobs.getGCManager().useNewBlockProtection)
            return;
        HashMap<String, chunkData> world = map.get(chunk.getWorld().getName());
        if (world == null)
            return;

        world.remove(chunk.getX() + ":" + chunk.getZ());
    }

    public void addProtection(Block block, Integer cd) {

        if (cd == null || cd == 0)
            return;

        // Assuming that block is bottom part of flower we will add top part to the record too
        switch (CMIMaterial.get(block)) {
        case LILAC:
        case SUNFLOWER:
        case ROSE_BUSH:
        case PEONY:
            CMIBlock cmb = new CMIBlock(block);
            // We are only interested in this being bottom block as this should never trigger for top part of placed block
            if (cmb.getBisect().equals(Bisect.BOTTOM))
                addProtection(block.getLocation().clone().add(0, 1, 0).getBlock(), cd, true);
            break;
        }

        addProtection(block, cd, true);
    }

    public void addProtection(Block block, Integer cd, boolean paid) {
        if (cd == null || cd == 0)
            return;

        addProtection(block, cd != -1 ? System.currentTimeMillis() + (cd * 1000) : -1, paid);
    }

    private String convertLoc(Location loc) {
        return convertLoc(loc.toVector());
    }

    private String convertLoc(Vector loc) {
        return loc.getBlockX() + "." + loc.getBlockY() + "." + loc.getBlockZ();
    }

    private int shortenLong(long value) {
        if (value == -1)
            return -1;
        return (int) (value / 1000) - 2147483647;
    }

    private Long deconvertLong(Integer value) {
        if (value == null)
            return null;
        if (value == -1)
            return -1L;

        return (value + 2147483647L) * 1000L;
    }

    public ExploitProtection addProtection(Block block, Long protectedUntil, boolean paid) {
        if (!Jobs.getGCManager().useNewBlockProtection) {
            BlockProtection protection = Jobs.getBpManager().addP(block.getLocation(), protectedUntil, paid, true);

            ExploitProtection ep = new ExploitProtection(block.getLocation().toVector());
            ep.setPaid(protection.isPaid());
            ep.setProtectedUntil(protection.getTime());
            return ep;
        }

        if (protectedUntil == null || protectedUntil == 0)
            return null;

        if (block == null)
            return null;

        CMIChunkPersistentDataContainer pdc = getPDC(block);

        if (pdc == null)
            return null;

        String locString = convertLoc(block.getLocation());

        pdc.set(locString, NAMETIME, shortenLong(protectedUntil));
        if (!paid)
            pdc.set(locString, NAMEPAID, paid);
        else
            pdc.remove(locString, NAMEPAID);
        pdc.save();

        ExploitProtection ep = new ExploitProtection(block.getLocation().toVector());
        ep.setPaid(paid);
        ep.setProtectedUntil(protectedUntil);

        return ep;
    }

    public void remove(Block block) {
        if (!Jobs.getGCManager().useNewBlockProtection) {
            Jobs.getBpManager().remove(block);
            return;
        }

        // In case double plant was destroyed we should remove both blocks from records
        CMIMaterial cmat = CMIMaterial.get(block);
        switch (cmat) {
        case LILAC:
        case SUNFLOWER:
        case ROSE_BUSH:
        case PEONY:
            CMIBlock cmb = new CMIBlock(block);
            if (cmb.getBisect().equals(Bisect.BOTTOM)) {
                block = block.getLocation().clone().add(0, 1, 0).getBlock();
            } else {
                block = block.getLocation().clone().add(0, -1, 0).getBlock();
            }
            return;
        }

        CMIChunkPersistentDataContainer pdc = getPDC(block);
        String locString = convertLoc(block.getLocation());
        pdc.remove(locString);
        pdc.save();
    }

    public Long getTime(Block block) {

        if (!Jobs.getGCManager().useNewBlockProtection)
            return Jobs.getBpManager().getTime(block);

        CMIChunkPersistentDataContainer pdc = getPDC(block);
        if (pdc == null)
            return null;

        String locString = convertLoc(block.getLocation());

        return deconvertLong(pdc.getInt(locString, NAMETIME));
    }

    public Long getTime(Location loc) {
        return getTime(loc.getBlock());
    }

    @Deprecated
    public Integer getBlockProtectionTime(Block block) {
        return getBlockProtectionTime(ActionType.PLACE, block);
    }

    public Integer getBlockProtectionTime(ActionType action, Block block) {

        switch (action) {
        case BREAK:
            if (Jobs.getGCManager().useGlobalBreakTimer)
                return Jobs.getGCManager().globalBlockBreakTimer;
            break;
        case PLACE:
            Integer time = Jobs.getRestrictedBlockManager().restrictedBlocksTimer.get(CMIMaterial.get(block));
            if (time == null && Jobs.getGCManager().useGlobalTimer)
                return Jobs.getGCManager().globalblocktimer;
            return time == null ? 0 : time;
        }

        return 0;
    }

    public boolean isInProtection(Block block) {
        return Jobs.getRestrictedBlockManager().restrictedBlocksTimer.containsKey(CMIMaterial.get(block));
    }

    public void setPaid(Block block, boolean paid) {
        CMIChunkPersistentDataContainer pdc = getPDC(block);
        String locString = convertLoc(block.getLocation());
        if (!paid)
            pdc.set(locString, NAMEPAID, paid);
        else
            pdc.remove(locString, NAMEPAID);
        pdc.save();
    }

    private ExploitProtection getProtection(Block block) {

        ExploitProtection ep = new ExploitProtection(block.getLocation().toVector());

        CMIChunkPersistentDataContainer pdc = getPDC(block);

        String locString = convertLoc(block.getLocation());
        Boolean paidValue = pdc.getBoolean(locString, NAMEPAID);
        ep.setPaid(paidValue == null ? true : paidValue);
        ep.setProtectedUntil(deconvertLong(pdc.getInt(locString, NAMETIME)));
        return ep;
    }

    public boolean isProtectionValidAddIfNotExists(JobsPlayer player, ActionInfo info, Block block, boolean inform) {
        if (!Jobs.getGCManager().useNewBlockProtection)
            return Jobs.getBpManager().isBpOk(player, info, block, inform);

        if (block == null || !Jobs.getGCManager().useBlockProtection)
            return true;

        if (info.getType() == ActionType.BREAK) {
            if (block.hasMetadata("JobsExploit")) {
                //player.sendMessage("This block is protected using Rukes' system!");
                return false;
            }

            ExploitProtection exploitProtection = getProtection(block);

            if (exploitProtection.getProtectedUntil() != 0) {
                long time = exploitProtection.getProtectedUntil();

                if (time == -1L) {
                    remove(block);
                    return false;
                }

                if (time < System.currentTimeMillis()) {
                    remove(block);
                    return true;
                }

                if (time > System.currentTimeMillis() || exploitProtection.isPaid()) {
                    if (inform && player.canGetPaid(info))
                        CMIActionBar.send(player.getPlayer(), Jobs.getLanguage().getMessage("message.blocktimer", "[time]", Math.round((time - System.currentTimeMillis()) / 1000L)));
                    return false;
                }

                addProtection(block, getBlockProtectionTime(info.getType(), block));

            } else {
                addProtection(block, getBlockProtectionTime(info.getType(), block));
            }
        } else if (info.getType() == ActionType.PLACE) {
            ExploitProtection exploitProtection = getProtection(block);
            if (exploitProtection.getProtectedUntil() != 0) {

                long time = exploitProtection.getProtectedUntil();

                Integer cd = getBlockProtectionTime(info.getType(), block);
                if (time != -1L) {
                    if (time < System.currentTimeMillis()) {
                        addProtection(block, cd);
                        return true;
                    }

                    if ((time > System.currentTimeMillis() || exploitProtection.isPaid())) {
                        if (inform && player.canGetPaid(info))
                            CMIActionBar.send(player.getPlayer(), Jobs.getLanguage().getMessage("message.blocktimer", "[time]", Math.round((time - System.currentTimeMillis()) / 1000L)));
                        addProtection(block, cd);
                        return false;
                    }

                    // Lets add protection in any case
                    addProtection(block, cd);
                } else if (exploitProtection.isPaid() && exploitProtection.getProtectedUntil() == -1L && cd != null && cd == -1) {
                    addProtection(block, cd);
                    return false;
                } else
                    addProtection(block, cd);
            } else {
                addProtection(block, getBlockProtectionTime(info.getType(), block));
            }
        }

        return true;
    }

    public void cleanChunk(Chunk chunk) {

        if (!Jobs.getGCManager().useNewBlockProtection)
            return;

        try {

            chunkData pdc = getChunkData(chunk);

            if (pdc == null)
                return;

            // Delay to clean it up once more to prevent rapid updates of same chunk
            if (pdc.getLastClean() + (30 * 1000L) > System.currentTimeMillis())
                return;

            Set<NamespacedKey> keys = pdc.getContainer().getKeys();

            for (NamespacedKey one : keys) {
                Long time = deconvertLong(pdc.getContainer().getInt(one.getKey(), NAMETIME));
                if (time != null && time != -1 && time < System.currentTimeMillis()) {
                    pdc.getContainer().remove(one.getKey());
                }
            }
            pdc.getContainer().save();
            pdc.setLastClean(System.currentTimeMillis());

        } catch (Throwable e) {
            e.printStackTrace();
        }
    }
}
